esphome:
  name: can-bus01
  friendly_name: can-bus01

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: INFO
# This YAML file is optimised to run two R48xxGx units in parallel on the same CAN BUS. COMMUNICATION VIA MQTT.
# If you dont have or want to use Home assistant or do any automation, just need a simple web surface to 
# control your recifiers, just fill out your wifi credentials, uncomment this webs_server: section and 
# comment out the "api:" section and the "mqtt:" section. and compile and upload bin to esp32 
# using any PC: https://www.youtube.com/watch?v=BX6tDsux_X4 

########
#web_server:
 # version: 3
########

# Uncomment api: block if you are using Home Assistant
#######
api:
 encryption:
   key: "Np7EDGpTJZPZphuc+WA2vIt34DHI7hpXM9gPVnHOICg="
#######
ota:
  - platform: esphome
    password: "afafd3c4bba9467b8f842f8d622f1435"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Can-Bus01 Fallback Hotspot"
    password: "Qjk3nwK8gpqw"

captive_portal:


# # Uncomment this mqtt: block AND the mqtt block at the bottom of this file if you plan to use it. The status and control topics are shown in the Log also.
# ########
mqtt:
   broker: !secret mqtt_host
   username: !secret mqtt_username
   password: !secret mqtt_password
   id: mqtt_client
 ########

globals:
  - id: amp_scaling_factor
    type: int
    initial_value: "15"
    restore_value: True
    
  - id: voltage_scaling_factor
    type: int
    initial_value: "1024"
    restore_value: True

  - id: max_amp_limit
    type: float
    initial_value: "75"  # Set your default max value here
    restore_value: True


script:
  - id: set_max_amp_limit
    mode: queued
    then:
      - lambda: |-
          // Adjust max amp limit dynamically based on the model
          if (id(amp_scaling_factor) == 15) {
            id(max_amp_limit) = 75.0;
          } else if (id(amp_scaling_factor) == 20) {
            id(max_amp_limit) = 50.0;
          } else if (id(amp_scaling_factor) == 30) {
            id(max_amp_limit) = 30.0;
          }
          ESP_LOGI("custom", "Max Amp Limit set to %.1f", id(max_amp_limit));


canbus:
  - platform: esp32_can
    tx_pin: GPIO19
    rx_pin: GPIO02
    can_id: 0xE5F32E5
    bit_rate: 125kbps
    use_extended_id: true
    on_frame:
      - can_id: 0x1081407F
        use_extended_id: true
        then:
          - lambda: |-
              if (x.size() >= 8) {
                const uint8_t byte_0 = static_cast<uint8_t>(x[0]);
                const uint8_t byte_1 = static_cast<uint8_t>(x[1]);
                const uint32_t value = (static_cast<uint32_t>(x[4]) << 24) | 
                                       (static_cast<uint32_t>(x[5]) << 16) | 
                                       (static_cast<uint32_t>(x[6]) << 8) | 
                                       static_cast<uint32_t>(x[7]);
                switch (byte_0) {
                  case 0x01:
                    switch (byte_1) {
                      case 0x70: id(ac_power_in_sensor1).publish_state(value); break;
                      case 0x71: id(grid_frequency_sensor1).publish_state(value); break;
                      case 0x72: id(input_current_sensor1).publish_state(value); break;
                      case 0x73: id(dc_power_out_sensor1).publish_state(value); break;
                      case 0x75: id(output_voltage_sensor1).publish_state(value); break;
                      case 0x76: id(set_max_output_current_sensor1).publish_state(value); break;
                      case 0x78: id(input_grid_voltage_sensor1).publish_state(value); break;
                      case 0x7F: id(output_temperature_sensor1).publish_state(value); break;
                      case 0x81: id(output_current_sensor1).publish_state(value); break;
                    }
                    break;
                }
              }
      - can_id: 0x1001117E
        use_extended_id: true
        then:
          - lambda: |-
              if (x.size() == 8) {
                // Extract the state byte (x[3])
                const uint8_t state_byte = x[3];

                // Extract the error byte (x[4])
                const uint8_t error_byte = x[4];

                // Extract altAMP from the last two bytes
                const uint16_t alt_amp_value = 
                  (static_cast<uint16_t>(x[6]) << 8) | 
                  static_cast<uint16_t>(x[7]);

                // Publish alt AMP values
                id(alt_amp_sensor1).publish_state(alt_amp_value);

                // Determine power state
                if (error_byte == 1) {
                  id(power_state_sensor1).publish_state("ERROR");
                  ESP_LOGW("CAN_BUS", 
                    "Device 1 entered error state. Error byte: 0x%02X. Full message: [0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X]", 
                    error_byte, 
                    x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]);
                } else if (state_byte == 0) {
                  id(power_state_sensor1).publish_state("ON");
                } else {
                  id(power_state_sensor1).publish_state("OFF");
                }
              }
   
      - can_id: 0x1081D27F
        use_extended_id: true
        then:
          - lambda: |-
              static std::string accumulated_data = "";  // Buffer to accumulate data across frames
              static int expected_frame_id = 0;  // Track expected frame ID for sequence validation
              static bool message_complete = false;  // Track if the message is complete
              static unsigned long last_frame_time = millis();  // Track time of the last frame

              // Timeout mechanism: Reset buffer if no frames are received for 500ms
              if (millis() - last_frame_time > 500) {
                ESP_LOGW("CAN_BUS", "Timeout detected, resetting buffer.");
                accumulated_data.clear();
                expected_frame_id = 0;
                message_complete = false;
              }
              last_frame_time = millis();  // Update the last frame time

              // Extract the frame ID from the first two bytes
              int frame_id = (x[0] << 8) | x[1];

              // Check for out-of-sequence frames
              if (frame_id != expected_frame_id) {
                ESP_LOGW("CAN_BUS", "Out of sequence frame received! Expected: %d, Got: %d", expected_frame_id, frame_id);
                expected_frame_id = frame_id + 1;  // Adjust expected frame ID
              } else {
                expected_frame_id = frame_id + 1;  // Update for the next expected frame
              }

              // Append ASCII data from the frame (starting from byte 2)
              for (size_t i = 2; i < x.size(); i++) {
                char c = static_cast<char>(x[i]);
                if (isprint((unsigned char)c) || c == '\n' || c == '\r') {  // Filter valid printable characters
                  accumulated_data += c;
                }
              }

              // Check for the "BO" marker to indicate end of the message
              if (accumulated_data.size() >= 2 &&
                  accumulated_data.substr(accumulated_data.size() - 2) == "BO") {
                message_complete = true;
              }

              // Process the complete message when detected
              if (message_complete) {
                ESP_LOGI("CAN_BUS", "Complete message received: %s", accumulated_data.c_str());

                // Helper lambda for extracting values of the form "Key="
                auto extract_value = [&](const std::string &data, const std::string &key) -> std::string {
                  size_t start = data.find(key);
                  if (start == std::string::npos) return "";
                  start += key.size();
                  size_t end = data.find_first_of("\r\n ", start);
                  if (end == std::string::npos)
                    end = data.size();
                  return data.substr(start, end - start);
                };

                // Extract the Board Type (R48xxGx)
                {
                  size_t pos = accumulated_data.find("R48");
                  if (pos != std::string::npos && pos + 6 < accumulated_data.size()) {
                    if (isdigit((unsigned char)accumulated_data[pos + 3]) &&
                        isdigit((unsigned char)accumulated_data[pos + 4]) &&
                        accumulated_data[pos + 5] == 'G' &&
                        isalnum((unsigned char)accumulated_data[pos + 6])) {
                      std::string board_type_str = accumulated_data.substr(pos, 7);
                      ESP_LOGI("CAN_BUS", "Board Type found: %s", board_type_str.c_str());
                      id(board1_type).publish_state(board_type_str.c_str());

                      // Set amp_scaling_factor based on board type
                      if (board_type_str.find("R4830") == 0) {
                        id(amp_scaling_factor) = 30;
                        ESP_LOGI("CAN_BUS", "amp_scaling_factor set to 30 for R4830");
                        id(sf_description).publish_state("SF 30 for R4830G");
                      } else if (board_type_str.find("R4850") == 0) {
                        id(amp_scaling_factor) = 20;
                        ESP_LOGI("CAN_BUS", "amp_scaling_factor set to 20 for R4850");
                        id(sf_description).publish_state("SF 20 for R4850G");
                      } else if (board_type_str.find("R4875") == 0) {
                        id(amp_scaling_factor) = 15;
                        ESP_LOGI("CAN_BUS", "amp_scaling_factor set to 15 for R4875");
                        id(sf_description).publish_state("SF 15 for R4875G");
                      }
                    }
                  }
                }

                // Extract Barcode
                std::string barcode_str = extract_value(accumulated_data, "BarCode=");
                if (!barcode_str.empty()) {
                  ESP_LOGI("CAN_BUS", "Barcode found: %s", barcode_str.c_str());
                  id(barcode_sensor).publish_state(barcode_str.c_str());
                }

                // Extract Manufacturing Date
                std::string manufactured_date = extract_value(accumulated_data, "Manufactured=");
                if (!manufactured_date.empty()) {
                  ESP_LOGI("CAN_BUS", "Manufacturing Date found: %s", manufactured_date.c_str());
                  id(manufacturing_date_sensor1).publish_state(manufactured_date.c_str());
                }

                // Clear buffer after processing the complete message
                accumulated_data.clear();
                expected_frame_id = 0;  // Reset sequence tracking
                message_complete = false;  // Reset the message complete flag
              }

      # Handle messages from the second device
      - can_id: 0x1082407F
        use_extended_id: true
        then:
          - lambda: |-
              if (x.size() >= 8) {
                const uint8_t byte_0 = static_cast<uint8_t>(x[0]);
                const uint8_t byte_1 = static_cast<uint8_t>(x[1]);
                const uint32_t value = (static_cast<uint32_t>(x[4]) << 24) | 
                                       (static_cast<uint32_t>(x[5]) << 16) | 
                                       (static_cast<uint32_t>(x[6]) << 8) | 
                                       static_cast<uint32_t>(x[7]);
                switch (byte_0) {
                  case 0x01:
                    switch (byte_1) {
                      case 0x70: id(ac_power_in_sensor_device2).publish_state(value); break;
                      case 0x71: id(grid_frequency_sensor_device2).publish_state(value); break;
                      case 0x72: id(input_current_sensor_device2).publish_state(value); break;
                      case 0x73: id(dc_power_out_sensor_device2).publish_state(value); break;
                      case 0x75: id(output_voltage_sensor_device2).publish_state(value); break;
                      case 0x76: id(set_max_output_current_sensor_device2).publish_state(value); break;
                      case 0x78: id(input_grid_voltage_sensor_device2).publish_state(value); break;
                      case 0x7F: id(output_temperature_sensor_device2).publish_state(value); break;
                      case 0x81: id(output_current_sensor_device2).publish_state(value); break;
                    }
                    break;
                }
              }
     
      - can_id: 0x1002117E
        use_extended_id: true
        then:
          - lambda: |-
              if (x.size() == 8) {
                // Extract the state byte (x[3])
                const uint8_t state_byte = x[3];

                // Extract the error byte (x[4])
                const uint8_t error_byte = x[4];

                // Extract altAMP from the last two bytes
                const uint16_t alt_amp_value = 
                  (static_cast<uint16_t>(x[6]) << 8) | 
                  static_cast<uint16_t>(x[7]);

                // Publish alt AMP values
                id(alt_amp_sensor2).publish_state(alt_amp_value);

                // Determine power state
                if (error_byte == 1) {
                  id(power_state_sensor2).publish_state("ERROR");
                  ESP_LOGW("CAN_BUS", 
                    "Device 2 entered error state. Error byte: 0x%02X. Full message: [0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X]", 
                    error_byte, 
                    x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]);
                } else if (state_byte == 0) {
                  id(power_state_sensor2).publish_state("ON");
                } else {
                  id(power_state_sensor2).publish_state("OFF");
                }
              }


      - can_id: 0x1082D27F
        use_extended_id: true
        then:
          - lambda: |-
              static std::string accumulated_data = "";  // Buffer to accumulate data across frames
              static int expected_frame_id = 0;  // Track expected frame ID for sequence validation
              static bool message_complete = false;  // Track if the message is complete
              static unsigned long last_frame_time = millis();  // Track time of the last frame

              // Timeout mechanism: Reset buffer if no frames are received for 500ms
              if (millis() - last_frame_time > 500) {
                ESP_LOGW("CAN_BUS", "Timeout detected, resetting buffer.");
                accumulated_data.clear();
                expected_frame_id = 0;
                message_complete = false;
              }
              last_frame_time = millis();  // Update the last frame time

              // Extract the frame ID from the first two bytes
              int frame_id = (x[0] << 8) | x[1];

              // Check for out-of-sequence frames
              if (frame_id != expected_frame_id) {
                ESP_LOGW("CAN_BUS", "Out of sequence frame received! Expected: %d, Got: %d", expected_frame_id, frame_id);
                expected_frame_id = frame_id + 1;  // Adjust expected frame ID
              } else {
                expected_frame_id = frame_id + 1;  // Update for the next expected frame
              }

              // Append ASCII data from the frame (starting from byte 2)
              for (size_t i = 2; i < x.size(); i++) {
                char c = static_cast<char>(x[i]);
                if (isprint((unsigned char)c) || c == '\n' || c == '\r') {  // Filter valid printable characters
                  accumulated_data += c;
                }
              }

              // Check for the "BO" marker to indicate end of the message
              if (accumulated_data.size() >= 2 &&
                  accumulated_data.substr(accumulated_data.size() - 2) == "BO") {
                message_complete = true;
              }

              // Process the complete message when detected
              if (message_complete) {
                ESP_LOGI("CAN_BUS", "Complete message received: %s", accumulated_data.c_str());

                // Helper lambda for extracting values of the form "Key="
                auto extract_value = [&](const std::string &data, const std::string &key) -> std::string {
                  size_t start = data.find(key);
                  if (start == std::string::npos) return "";
                  start += key.size();
                  size_t end = data.find_first_of("\r\n ", start);
                  if (end == std::string::npos)
                    end = data.size();
                  return data.substr(start, end - start);
                };

                // Extract the Board Type (R48xxGx)
                {
                  size_t pos = accumulated_data.find("R48");
                  if (pos != std::string::npos && pos + 6 < accumulated_data.size()) {
                    if (isdigit((unsigned char)accumulated_data[pos + 3]) &&
                        isdigit((unsigned char)accumulated_data[pos + 4]) &&
                        accumulated_data[pos + 5] == 'G' &&
                        isalnum((unsigned char)accumulated_data[pos + 6])) {
                      std::string board_type_str = accumulated_data.substr(pos, 7);
                      ESP_LOGI("CAN_BUS", "Board Type found: %s", board_type_str.c_str());
                      id(board2_type).publish_state(board_type_str.c_str());

                      // Set amp_scaling_factor based on board type
                      if (board_type_str.find("R4830") == 0) {
                        id(amp_scaling_factor) = 30;
                        ESP_LOGI("CAN_BUS", "amp_scaling_factor set to 30 for R4830");
                        id(sf_description).publish_state("SF 30 for R4830G");
                      } else if (board_type_str.find("R4850") == 0) {
                        id(amp_scaling_factor) = 20;
                        ESP_LOGI("CAN_BUS", "amp_scaling_factor set to 20 for R4850");
                        id(sf_description).publish_state("SF 20 for R4850G");
                      } else if (board_type_str.find("R4875") == 0) {
                        id(amp_scaling_factor) = 15;
                        ESP_LOGI("CAN_BUS", "amp_scaling_factor set to 15 for R4875");
                        id(sf_description).publish_state("SF 15 for R4875G");
                      }
                    }
                  }
                }

                // Extract Barcode
                std::string barcode_str = extract_value(accumulated_data, "BarCode=");
                if (!barcode_str.empty()) {
                  ESP_LOGI("CAN_BUS", "Barcode found: %s", barcode_str.c_str());
                  id(barcode2_sensor).publish_state(barcode_str.c_str());
                }

                // Extract Manufacturing Date
                std::string manufactured_date = extract_value(accumulated_data, "Manufactured=");
                if (!manufactured_date.empty()) {
                  ESP_LOGI("CAN_BUS", "Manufacturing Date found: %s", manufactured_date.c_str());
                  id(manufacturing_date_sensor2).publish_state(manufactured_date.c_str());
                }

                // Clear buffer after processing the complete message
                accumulated_data.clear();
                expected_frame_id = 0;  // Reset sequence tracking
                message_complete = false;  // Reset the message complete flag
              }

time:
  - platform: sntp
    id: sntp_time






sensor:

  - platform: template
    name: "Output Current alt1"
    id: alt_amp_sensor1
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(amp_scaling_factor);  
    icon: "mdi:current-dc"

  - platform: template
    name: "Output Current alt2"
    id: alt_amp_sensor2
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(amp_scaling_factor);  
    icon: "mdi:current-dc"

  - platform: template
    name: "AC Power In1"
    id: ac_power_in_sensor1
    unit_of_measurement: "W"
    accuracy_decimals: 2
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:flash"
    update_interval: 1s  # Updates every second

  - platform: template
    name: "DC Power Out1"
    id: dc_power_out_sensor1
    unit_of_measurement: "W"
    accuracy_decimals: 2
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:flash"
    update_interval: 1s  # Updates every second

  - platform: template
    name: "Grid Frequency1"
    id: grid_frequency_sensor1
    unit_of_measurement: "Hz"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:transmission-tower-import"

  - platform: template
    name: "Input Current1"
    id: input_current_sensor1
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:current-ac"

  - platform: template
    name: "Output Voltage1"
    id: output_voltage_sensor1
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:current-dc"

  - platform: template
    name: "Input Grid Voltage1"
    id: input_grid_voltage_sensor1
    unit_of_measurement: "V"
    accuracy_decimals: 2
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:sine-wave"

  - platform: template
    name: "Output Temperature1"
    id: output_temperature_sensor1
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:thermometer"
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(output_temperature_sensor1).state > 90.0;'
            then:
              - canbus.send:
                  use_extended_id: true
                  can_id: 0x108180FE
                  data: [1, 50, 0, 1, 0, 0, 0, 0]
              - logger.log:
                  level: INFO
                  format: "Temperature exceeded 90°C. Sent CAN OFF message."

  - platform: template
    name: "Output Current1"
    id: output_current_sensor1
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:current-dc"

  - platform: template
    name: "Set Max Output Current1"
    id: set_max_output_current_sensor1
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(amp_scaling_factor);  
    icon: "mdi:current-ac"

  - platform: template
    name: "AC Power In2"
    id: ac_power_in_sensor_device2
    unit_of_measurement: "W"
    accuracy_decimals: 2
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:flash"
    update_interval: 1s  # Updates every second

  # Combined AC Power sensor
  - platform: template
    name: "Combined AC Power"
    id: combined_ac_power_sensor
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - multiply: 0.001
    update_interval: 1s  # Updates every second
    lambda: |-
      return id(ac_power_in_sensor1).state + id(ac_power_in_sensor_device2).state;
    icon: "mdi:flash"

  - platform: template
    name: "DC Power Out2"
    id: dc_power_out_sensor_device2
    unit_of_measurement: "W"
    accuracy_decimals: 2
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:flash"
    update_interval: 1s  # Updates every second

  # Combined DC Power sensor
  - platform: template
    name: "Combined DC Power"
    id: combined_dc_power_sensor
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    update_interval: 1s  # Updates every second
    filters:
      - multiply: 0.001
    lambda: |-
      return id(dc_power_out_sensor1).state + id(dc_power_out_sensor_device2).state;
    icon: "mdi:flash"

  # Combined Daily AC Energy kWh sensor
  - platform: total_daily_energy
    name: "AC Power In Total (kWh)"
    power_id: combined_ac_power_sensor
    time_id: sntp_time
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    icon: "mdi:counter"

  # Combined Daily DC Energy kWh sensor
  - platform: total_daily_energy
    name: "DC Power Out Total (kWh)"
    power_id: combined_dc_power_sensor
    time_id: sntp_time
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    icon: "mdi:counter"

  - platform: template
    name: "Grid Frequency2"
    id: grid_frequency_sensor_device2
    unit_of_measurement: "Hz"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:transmission-tower-import"

  - platform: template
    name: "Input Current2"
    id: input_current_sensor_device2
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:current-ac"

  - platform: template
    name: "Output Voltage2"
    id: output_voltage_sensor_device2
    unit_of_measurement: "V"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:current-dc"

  - platform: template
    name: "Input Grid Voltage2"
    id: input_grid_voltage_sensor_device2
    unit_of_measurement: "V"
    accuracy_decimals: 2
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:sine-wave"

  - platform: template
    name: "Output Temperature2"
    id: output_temperature_sensor_device2
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:thermometer"
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(output_temperature_sensor1).state > 90.0;'
            then:
              - canbus.send:
                  use_extended_id: true
                  can_id: 0x108280FE
                  data: [1, 50, 0, 1, 0, 0, 0, 0]
              - logger.log:
                  level: INFO
                  format: "Temperature exceeded 90°C. Sent CAN OFF message."

  - platform: template
    name: "Output Current2"
    id: output_current_sensor_device2
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(voltage_scaling_factor);  
    icon: "mdi:current-dc"

  - platform: template
    name: "Set Max Output Current2"
    id: set_max_output_current_sensor_device2
    unit_of_measurement: "A"
    accuracy_decimals: 1
    filters:
      - lambda: |-
          return x / id(amp_scaling_factor);  
    icon: "mdi:current-ac"


number:
  - platform: template
    name: "CAN Voltage Set"
    id: can_voltage_input
    min_value: 49
    max_value: 58
    step: 0.1
    unit_of_measurement: "V"
    optimistic: true
    mode: BOX
    restore_value: True
    on_value:
      then:
        - lambda: |-
            float voltage_value = id(can_voltage_input).state;
            int scaled_value = (int)(voltage_value * id(voltage_scaling_factor));
            ESP_LOGD("custom", "Received voltage: %.1fV, Scaled value: %d", voltage_value, scaled_value);
            
            uint8_t high_byte = (scaled_value >> 8) & 0xFF;
            uint8_t low_byte = scaled_value & 0xFF;
            ESP_LOGI("custom", "Encoded CAN message: [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x%02X, 0x%02X]", high_byte, low_byte);

        - canbus.send:
            use_extended_id: true
            can_id: 0x108080FE
            data: !lambda |-
              std::vector<uint8_t> can_data(8, 0x00);
              can_data[0] = 0x01;
              int scaled_value = (int)(id(can_voltage_input).state * id(voltage_scaling_factor));
              can_data[6] = (scaled_value >> 8) & 0xFF;
              can_data[7] = scaled_value & 0xFF;
              return can_data;

  # Amp Setting
  - platform: template
    name: "CAN Amp Set"
    id: can_amp_input
    min_value: 1
    max_value: 75 
    step: 1
    unit_of_measurement: "A"
    optimistic: true
    mode: BOX
    restore_value: true
    icon: "mdi:current-dc"
    on_value:
      then:
        - delay: 0.01s
        - lambda: |-
            float amp_value = id(can_amp_input).state;
            float max_amps = 75;  // Default max amps
            if (id(amp_scaling_factor) == 15) {
              max_amps = 75;
            } else if (id(amp_scaling_factor) == 20) {
              max_amps = 50;
            } else if (id(amp_scaling_factor) == 30) {
              max_amps = 30;
            }

            if (amp_value > max_amps) {
              ESP_LOGW("custom", "Entered Amp %.1f exceeds max limit %.1f for model, resetting.", amp_value, max_amps);
              id(can_amp_input).publish_state(max_amps);  // Reset to max value
              return;
            }

            int scaled_value = (int)(amp_value * id(amp_scaling_factor));
            ESP_LOGI("custom", "Validated Amp: %.1fA, Scaled value: %d", amp_value, scaled_value);

            uint8_t high_byte = (scaled_value >> 8) & 0xFF;
            uint8_t low_byte = scaled_value & 0xFF;
            ESP_LOGI("custom", "Encoded CAN message: [0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x%02X, 0x%02X]", high_byte, low_byte);

        - canbus.send:
            use_extended_id: true
            can_id: 0x108080FE
            data: !lambda |-
              std::vector<uint8_t> can_data(8, 0x00);
              can_data[0] = 0x01;
              can_data[1] = 0x03;
              int scaled_value = (int)(id(can_amp_input).state * id(amp_scaling_factor));
              can_data[6] = (scaled_value >> 8) & 0xFF;
              can_data[7] = scaled_value & 0xFF;
              return can_data;

  # Fallback Amp Setting
  - platform: template
    name: "Fallback Amp Set"
    id: fallback_amp_input
    min_value: 1
    max_value: 75  
    step: 1
    unit_of_measurement: "A"
    optimistic: true
    mode: BOX
    restore_value: true
    icon: "mdi:current-dc"
    on_value:
      then:
        - delay: 0.01s
        - lambda: |-
            float fallback_amp_value = id(fallback_amp_input).state;
            float max_amps = 75;  // Default max amps
            if (id(amp_scaling_factor) == 15) {
              max_amps = 75;
            } else if (id(amp_scaling_factor) == 20) {
              max_amps = 50;
            } else if (id(amp_scaling_factor) == 30) {
              max_amps = 30;
            }

            if (fallback_amp_value > max_amps) {
              ESP_LOGW("custom", "Entered Fallback Amp %.1f exceeds max limit %.1f for model, resetting.", fallback_amp_value, max_amps);
              id(fallback_amp_input).publish_state(max_amps);  // Reset to max value
              return;
            }

            int fallback_scaled_value = (int)(fallback_amp_value * id(amp_scaling_factor));
            ESP_LOGI("custom", "Validated Fallback Amp: %.1fA, Scaled value: %d", fallback_amp_value, fallback_scaled_value);

            uint8_t high_byte = (fallback_scaled_value >> 8) & 0xFF;
            uint8_t low_byte = fallback_scaled_value & 0xFF;
            ESP_LOGI("custom", "Encoded CAN message: [0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x%02X, 0x%02X]", high_byte, low_byte);

        - canbus.send:
            use_extended_id: true
            can_id: 0x108080FE
            data: !lambda |-
              std::vector<uint8_t> can_data(8, 0x00);
              can_data[0] = 0x01;
              can_data[1] = 0x04;
              int scaled_value = (int)(id(fallback_amp_input).state * id(amp_scaling_factor));
              can_data[6] = (scaled_value >> 8) & 0xFF;
              can_data[7] = scaled_value & 0xFF;
              return can_data;

  # Fallback Voltage Setting
  - platform: template
    name: "Fallback Voltage Set"
    id: fallback_voltage_input
    min_value: 49
    max_value: 58  # Adjust as needed for your voltage range
    step: 0.1  # 0.1V steps
    unit_of_measurement: "V"
    optimistic: true
    mode: BOX
    restore_value: True
    on_value:
      then:
        - lambda: |-
            float fallback_voltage_value = id(fallback_voltage_input).state;  // Get the fallback voltage value
            int fallback_scaled_value = (int)(fallback_voltage_value * id(voltage_scaling_factor));  // Scale the voltage value
            ESP_LOGD("custom", "Fallback Voltage: %.1fV, Scaled value: %d", fallback_voltage_value, fallback_scaled_value);
            
            uint8_t high_byte = (fallback_scaled_value >> 8) & 0xFF;  // Get high byte
            uint8_t low_byte = fallback_scaled_value & 0xFF;  // Get low byte
            ESP_LOGI("custom", "Encoded CAN message: [0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x%02X, 0x%02X]", high_byte, low_byte);  // Log the CAN message data

        - canbus.send:
            use_extended_id: true
            can_id: 0x108080FE
            data: !lambda |-
              std::vector<uint8_t> can_data(8, 0x00);  // Initialize with 8 zeros
              can_data[0] = 0x01;  // First byte is always 0x01
              can_data[1] = 0x01;  // Second byte is 0x01 for the Fallback Voltage setting
              int fallback_scaled_value = (int)(id(fallback_voltage_input).state * id(voltage_scaling_factor));  // Scale the voltage value
              can_data[6] = (fallback_scaled_value >> 8) & 0xFF;  // Encode the high byte in the 7th byte
              can_data[7] = fallback_scaled_value & 0xFF;         // Encode the low byte in the 8th byte
              return can_data;

interval:

  # Interval for sending the first CAN message every 30 seconds
  - interval: 2s
    then:
      - canbus.send:
          use_extended_id: true
          can_id: 0x108040FE
          data: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

  # Interval for sending voltage CAN message every 30 seconds
  - interval: 30s
    then:
      - canbus.send:
          use_extended_id: true
          can_id: 0x108080FE
          data: !lambda |-
            std::vector<uint8_t> can_data(8, 0x00);  // Initialize with 8 zeros
            can_data[0] = 0x01;  // First byte is always 0x01
            int scaled_value = (int)(id(can_voltage_input).state * id(voltage_scaling_factor));  // Scale the voltage value
            can_data[6] = (scaled_value >> 8) & 0xFF;  // Encode the high byte in the 7th byte
            can_data[7] = scaled_value & 0xFF;         // Encode the low byte in the 8th byte
            return can_data;

  # Interval for sending Amp setting CAN message every 10 seconds
  - interval: 30s
    then:
      - canbus.send:
          use_extended_id: true
          can_id: 0x108080FE
          data: !lambda |-
            std::vector<uint8_t> can_data(8, 0x00);  // Initialize with 8 zeros
            can_data[0] = 0x01;  // First byte is always 0x01
            can_data[1] = 0x03;  // Second byte is 0x03
            int scaled_value = (int)(id(can_amp_input).state * id(amp_scaling_factor));  // Scale the Amp value
            can_data[6] = (scaled_value >> 8) & 0xFF;  // Encode the high byte in the 7th byte
            can_data[7] = scaled_value & 0xFF;         // Encode the low byte in the 8th byte
            return can_data;


# Define a button component for turning ON
button:
  - platform: template
    name: "CAN ON-ALL Button"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "CAN ON Button pressed, sending message: [0x01, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x108080FE
            data: [0x01, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

  - platform: template
    name: "CAN ON-1 Button"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "CAN ON Button pressed, sending message: [0x01, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x108180FE
            data: [0x01, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

  - platform: template
    name: "CAN ON-2 Button"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "CAN ON Button pressed, sending message: [0x01, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x108280FE
            data: [0x01, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

# Define a button component for turning OFF
  - platform: template
    name: "CAN OFF-ALL Button"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "CAN OFF Button pressed, sending message: [0x01, 0x32, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x108080FE
            data: [0x01, 0x32, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]

  - platform: template
    name: "CAN OFF-1 Button"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "CAN OFF Button pressed, sending message: [0x01, 0x32, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x108180FE
            data: [0x01, 0x32, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]
  - platform: template
    name: "CAN OFF-2 Button"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "CAN OFF Button pressed, sending message: [0x01, 0x32, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x108280FE
            data: [0x01, 0x32, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]

# Define a button component for setting the fan to full speed
  - platform: template
    name: "Fan Full Speed Button"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "Fan Full Speed Button pressed, sending message: [0x01, 0x34, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x108080FE
            data: [0x01, 0x34, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]

# Define a button component for setting the fan to auto mode
  - platform: template
    name: "Fan Auto Mode Button"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "Fan Auto Mode Button pressed, sending message: [0x01, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x108080FE
            data: [0x01, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

  - platform: template
    name: "Find Board 2"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "Request Module2 Description Button pressed, sending message: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x1082D2FE
            data: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
 
  - platform: template
    name: "Find Board 1"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("custom", "Request Module1 Description Button pressed, sending message: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]");
        - canbus.send:
            use_extended_id: true
            can_id: 0x1081D2FE
            data: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

# Define text sensor for "ON/OFF/ERROR" state
text_sensor:
  - platform: template
    id: power_state_sensor1
    name: "Board-1"
    
  - platform: template
    id: power_state_sensor2
    name: "Board-2"

  - platform: template
    name: "Board-1 Type"
    id: board1_type
    update_interval: never

  - platform: template
    name: "Board-1 SN:"
    id: barcode_sensor
    update_interval: never

  - platform: template
    name: "Board-2 Type"
    id: board2_type
    update_interval: never

  - platform: template
    name: "Board-2 SN:"
    id: barcode2_sensor
    update_interval: never

  - platform: template
    name: "Scaling Factor Description"
    id: sf_description
    icon: "mdi:information-outline"
    update_interval: never

  - platform: template
    name: "Board-1 Mfg:"
    id: manufacturing_date_sensor1
    update_interval: never

  - platform: template
    name: "Board-2 Mfg:"
    id: manufacturing_date_sensor2
    update_interval: never

# ###################################################################################################################################
# ##This Block must be added to enable voltage and currrent SET topics when using the mqtt: component
# ## Subscribe to MQTT topic to update CAN voltage

  - platform: mqtt_subscribe
    name: "CAN Voltage MQTT"
    id: mqtt_voltage_input
    topic: "home/canbus/voltage_set"
    internal: true  # This makes the sensor internal
    on_value:
      then:
        - delay: 0.01s  # Small delay to ensure the value is properly updated
        - lambda: |-
            // Convert MQTT message to float
            float mqtt_voltage = atof(x.c_str());
           
            // Update the number input with the new value
            if (mqtt_voltage >= 49.0 && mqtt_voltage <= 58.0) {
              id(can_voltage_input).publish_state(mqtt_voltage);
              ESP_LOGI("custom", "MQTT Voltage Set to: %.1fV", mqtt_voltage);
            } else {
              ESP_LOGW("custom", "Received out-of-range voltage value: %.1fV", mqtt_voltage);
            }
    # Subscribe to MQTT topic to update CAN amps
  - platform: mqtt_subscribe
    name: "CAN Amps MQTT"
    id: mqtt_amp_input
    topic: "home/canbus/amp_set"
    internal: true  # This makes the sensor internal
    on_value:
      then:
        - delay: 0.01s  # Small delay to ensure the value is properly updated
        - lambda: |-
            // Convert MQTT message to float
            float mqtt_amp = atof(x.c_str());
           
            // Update the number input with the new value
            if (mqtt_amp >= 1.0 && mqtt_amp <= 75.0) {
              id(can_amp_input).publish_state(mqtt_amp);
              ESP_LOGI("custom", "MQTT Amp Set to: %.1fA", mqtt_amp);
            } else {
              ESP_LOGW("custom", "Received out-of-range amp value: %.1fA", mqtt_amp);
            }
    # Subscribe to MQTT topic to update Fallback Voltage
  - platform: mqtt_subscribe
    name: "Fallback Voltage MQTT"
    id: mqtt_fallback_voltage
    topic: "home/canbus/fallback_voltage_set"
    internal: true  # This makes the sensor internal
    on_value:
      then:
        - delay: 0.01s  # Small delay to ensure the value is properly updated
        - lambda: |-
            // Convert MQTT message to float
            float fallback_voltage = atof(x.c_str());
           
            // Update the number input with the new value
            if (fallback_voltage >= 49.0 && fallback_voltage <= 58.0) {
              id(fallback_voltage_input).publish_state(fallback_voltage);
              ESP_LOGI("custom", "Fallback Voltage Set to: %.1fV", fallback_voltage);
            } else {
              ESP_LOGW("custom", "Received out-of-range fallback voltage value: %.1fV", fallback_voltage);
            }

 # Subscribe to MQTT topic to update Fallback Amps
  - platform: mqtt_subscribe
    name: "Fallback Amps MQTT"
    id: mqtt_fallback_amp
    topic: "home/canbus/fallback_amp_set"
    internal: true  # This makes the sensor internal
    on_value:
      then:
        - delay: 0.01s  # Small delay to ensure the value is properly updated
        - lambda: |-
            // Convert MQTT message to float
            float fallback_amp = atof(x.c_str());
           
            // Update the number input with the new value
            if (fallback_amp >= 1.0 && fallback_amp <= 75.0) {
              id(fallback_amp_input).publish_state(fallback_amp);
              ESP_LOGI("custom", "Fallback Amps Set to: %.1fA", fallback_amp);
            } else {
              ESP_LOGW("custom", "Received out-of-range fallback amp value: %.1fA", fallback_amp);
            } 
 ##############################################################################################################################
